double setpt[nact] = {0};

void init_controller()
{
    int i;
    double target[]={0,0.9,-2.2,   //FR B
                     0,0.9,-2.2,   //FL A
                     0,0.9,-2.2,   //RR A
                     0,0.9,-2.2};  //RL B
    
    for (i=0;i<nact;i++)
    {
        setpt[i]=target[i];
    }
}

void control_loop(const mjModel* m, mjData* d,
                  double q[nact], double u[nact], double base_x[3], double base_quat[4],
                  double base_angvel[3], double base_linacc[3], double base_linvel[3],
                  double pos_FR_shoulder[3], double pos_FL_shoulder[3], double pos_RR_shoulder[3], double pos_RL_shoulder[3],
                  double pos_FR_elbow[3], double pos_FL_elbow[3], double pos_RR_elbow[3], double pos_RL_elbow[3],
                  double pos_FR_foot[3], double pos_FL_foot[3], double pos_RR_foot[3], double pos_RL_foot[3], double robot_com[3], double tau[nact], int flag, int state, double t)
{
    int i;

    /*
        we have 3 ik solvers here:
            newton-raphson
                --- in order to find x to make F(x)=0, using iteration x(i+1) = x(i) - F(x(i))/F'(x(i))
                                        , which can also be written as x(i+1) = x(i) - inv(J)*F(x(i))
                --- in this case, we are trying to find hip, thigh, calf joints' angle (theta_hip, theta_thigh, theta_calf) given foot position (xref, yref, zref)
                    thus, we can treat this problem like this F1 = f1(theta_hip, theta_thigh, theta_calf) - xref = 0
                                                              F2 = f2(theta_hip, theta_thigh, theta_calf) - yref = 0
                                                              F3 = f3(theta_hip, theta_thigh, theta_calf) - zref = 0
                    f1, f2, f3 is the forward-kinematics equation generated by "a1_fk.m", corresponding to real foot position xyz
                --- this solver is sensitive to the initial guess
            
            jacobian approach
                --- reference from pranav's mujoco mini class charpter6 (https://pab47.github.io/mujoco.html)
                --- from end-effector linear velocity equation v=J*qdot ---> dr/dt=J*dq/dt ---> dr=J*dq ---> dq=inv(J)*dr
                --- this solver can only work in the time_continuous simulation

            analytic solution
                --- since a1 leg can be treated as double pendulum model, which has simple equations to descript the relationship between foot position and joints' angle
                    thus, we can directly solve these equations using basic quadratic equation algebra
                --- from forward kinematics we can have: xref = l1*sin(theta1) + l2*sin(theta1+theta2)
                                                         yref = l1*cos(theta1) + l2*cos(theta1+theta2)
                                                         assume ---> alpha = theta1 + theta2
                                                         xref - l1*sin(theta1) = l2*sin(alpha)
                                                         yref - l1*cos(theta1) = l2*cos(alpha)
                                                         square both sides
                                                         (xref - l1*sin(theta1))^2 = l2^2*sin(alpha)^2
                                                         (yref - l1*cos(theta1))^2 = l2^2*cos(alpha)^2
                                                         we got:
                                                         (xref - l1*sin(theta1))^2 + (yref - l1*cos(theta1))^2 = l2^2
                                                         open it up and do a little summary we got
                                                         xref^2 + yref^2 + l1^2 - 2*l1*(sin(theta1)*xref + cos(theta1)*yref) = l2^2
                                                         assume case1 ---> cos(theta1) = +sqrt(1-sin(theta1)^2)
                                                         assume case2 ---> cos(theta1) = -sqrt(1-sin(theta1)^2)
                                                            case1: xref^2 + yref^2 + l1^2 - l2^2 - 2*l1*xref*sin(theta1) = 2*l1*yref*sqrt(1-sin(theta1)^2)
                                                                   assume ---> a=xref^2+yref^2+l1^2-l2^2 
                                                                               b=2*l1*xref
                                                                               c=2*l1*yref
                                                                   we got: a - b*sin(theta1) = c*sqrt(1-sin(theta1)^2)
                                                                   square the both sides and do the little summary we got:
                                                                   (b^2+c^2)*sin(theta1)^2 - 2*a*b*sin(theta1) + (a^2-c^2) = 0
                                                                   using basic quadratic equation algebra ---> calculate sin(theta1) ---> got theta1_case1_1 & theta1_case1_2
                                                                                                          from alpha = theta1+theta2 ---> got theta2_case1_1 & theta2_case1_2
                                                            case2: we have the same process as case1, thus we can                    ---> got theta1_case2_1 & theta1_case2_2
                                                                                                          from alpha = theta1+theta2 ---> got theta2_case2_1 & theta2_case2_2
                --- above calculation can be done in "a1_analytic.m" then choose an appropriate angle set within these 4 sets of combinations
                --- this solver will not be sensitive to initial guess, only simple mechanism can use analytical method to do the ik since the simple fk equations
    */

    // ********************************************************* newton-raphson solvers ********************************************************* //
    // double THETA[3] = {};
    // double Jinv_F[3] = {};
    // double Jinv[9] = {};
    // double F[3] = {};

    // // initial guess
    // double theta_hip = 0;
    // double theta_thigh = 0.8;
    // double theta_calf = -1;

    // // target position --- check with pos_FR_foot --- this can be used in trajectory generation 
    // double xref = 0.183;
    // double yref = -0.1320;
    // double zref = 0.42;

    // // newton-raphson iteration loop
    // for (i=1; i<4000; i++)
    // {
    //     // Jinv and F are from "a1_fk.m"
    //     Jinv[0] = 0;
    //     Jinv[1] = (5.0*cos(theta_hip))/(cos(theta_calf + theta_thigh) + cos(theta_thigh));
    //     Jinv[2] = (5.0*sin(theta_hip))/(cos(theta_calf + theta_thigh) + cos(theta_thigh));
    //     Jinv[3] = -(5.0*sin(theta_calf + theta_thigh))/sin(theta_calf);
    //     Jinv[4] = -(0.00125*(4000.0*cos(theta_calf)*cos(theta_calf)*sin(theta_hip) - 4000.0*sin(theta_hip) + 4000.0*cos(theta_thigh)*cos(theta_thigh)*sin(theta_hip) - 1701.0*cos(theta_hip)*sin(theta_calf)*sin(theta_thigh) - 4000.0*cos(theta_calf)*cos(theta_thigh)*cos(theta_thigh)*sin(theta_hip) - 8000.0*cos(theta_calf)*cos(theta_calf)*cos(theta_thigh)*cos(theta_thigh)*sin(theta_hip) + 1701.0*cos(theta_hip)*cos(theta_calf)*cos(theta_thigh) + 4000.0*cos(theta_thigh)*sin(theta_hip)*sin(theta_calf)*sin(theta_thigh) + 8000.0*cos(theta_calf)*cos(theta_thigh)*sin(theta_hip)*sin(theta_calf)*sin(theta_thigh)))/(cos(theta_thigh)*sin(theta_calf) - 1.0*sin(theta_thigh) + cos(theta_calf)*cos(theta_calf)*sin(theta_thigh) + cos(theta_calf)*cos(theta_thigh)*sin(theta_calf));
    //     Jinv[5] = (0.00125*(4000.0*cos(theta_hip)*cos(theta_calf)*cos(theta_calf) - 4000.0*cos(theta_hip) + 4000.0*cos(theta_hip)*cos(theta_thigh)*cos(theta_thigh) + 1701.0*sin(theta_hip)*sin(theta_calf)*sin(theta_thigh) - 4000.0*cos(theta_hip)*cos(theta_calf)*cos(theta_thigh)*cos(theta_thigh) - 8000.0*cos(theta_hip)*cos(theta_calf)*cos(theta_calf)*cos(theta_thigh)*cos(theta_thigh) - 1701.0*cos(theta_calf)*cos(theta_thigh)*sin(theta_hip) + 4000.0*cos(theta_hip)*cos(theta_thigh)*sin(theta_calf)*sin(theta_thigh) + 8000.0*cos(theta_hip)*cos(theta_calf)*cos(theta_thigh)*sin(theta_calf)*sin(theta_thigh)))/(cos(theta_thigh)*sin(theta_calf) - 1.0*sin(theta_thigh) + cos(theta_calf)*cos(theta_calf)*sin(theta_thigh) + cos(theta_calf)*cos(theta_thigh)*sin(theta_calf));
    //     Jinv[6] = (5.0*(sin(theta_calf + theta_thigh) + sin(theta_thigh)))/sin(theta_calf);
    //     Jinv[7] = (0.00125*(1701.0*cos(theta_hip) - 4000.0*cos(theta_thigh)*sin(theta_hip) + 4000.0*sin(theta_hip)*sin(theta_calf)*sin(theta_thigh) - 4000.0*cos(theta_calf)*cos(theta_thigh)*sin(theta_hip)))/sin(theta_calf);
    //     Jinv[8] = (0.00125*(1701.0*sin(theta_hip) + 4000.0*cos(theta_hip)*cos(theta_thigh) - 4000.0*cos(theta_hip)*sin(theta_calf)*sin(theta_thigh) + 4000.0*cos(theta_hip)*cos(theta_calf)*cos(theta_thigh)))/sin(theta_calf);
    //     F[0] = 0.183 - 0.2*sin(theta_thigh) - 0.2*sin(theta_calf + theta_thigh) - xref;
    //     F[1] = 0.2*cos(theta_thigh)*sin(theta_hip) - 0.08505*cos(theta_hip) - 0.2*sin(theta_hip)*sin(theta_calf)*sin(theta_thigh) + 0.2*cos(theta_calf)*cos(theta_thigh)*sin(theta_hip) - 0.047 - yref;
    //     F[2] = 0.2*cos(theta_hip)*sin(theta_calf)*sin(theta_thigh) - 0.2*cos(theta_hip)*cos(theta_thigh) - 0.08505*sin(theta_hip) - 0.2*cos(theta_hip)*cos(theta_calf)*cos(theta_thigh) + 0.6 - zref;
    //     mju_mulMatVec(Jinv_F, Jinv, F, 3, 3);

    //     // solver --- x(i+1) = x(i) - inv(J)*F(x(i))
    //     THETA[0] = theta_hip   - Jinv_F[0];
    //     THETA[1] = theta_thigh - Jinv_F[1];
    //     THETA[2] = theta_calf  - Jinv_F[2];

    //     // input for torque pd controller
    //     theta_hip   = THETA[0];
    //     theta_thigh = THETA[1];
    //     theta_calf  = THETA[2];
    // }
    // // input for torque pd controller
    // double theta_hip_ctrl = theta_hip;
    // double theta_thigh_ctrl = theta_thigh;
    // double theta_calf_ctrl = theta_calf;
    // ********************************************************* newton-raphson solvers ********************************************************* //
    









    // ********************************************************* jacobian approach solvers ********************************************************* //
    // double Jinv[9] = {0};
    // double theta_hip = d->sensordata[0];
    // double theta_thigh = d->sensordata[1];
    // double theta_calf = d->sensordata[2];
    
    // // trajectory generation --- circle
    // double r = 0.1;
    // double omega = 0.5;
    // double x_0 = 0.219294 - r;
    // double y_0 = -0.131084;
    // double z_0 = 0.421041;
    // double x = x_0 + r*cos(omega*d->time);
    // double y = pos_FR_foot[1];
    // double z = z_0 + r*sin(omega*d->time);
    // double dr[3] = {x-pos_FR_foot[0], y, z-pos_FR_foot[2]};
    // double dq[3] = {};

    // // Jinv is from "a1_fk.m"
    // Jinv[0] = 0;
    // Jinv[1] = (5.0*cos(theta_hip))/(cos(theta_calf + theta_thigh) + cos(theta_thigh));
    // Jinv[2] = (5.0*sin(theta_hip))/(cos(theta_calf + theta_thigh) + cos(theta_thigh));
    // Jinv[3] = -(5.0*sin(theta_calf + theta_thigh))/sin(theta_calf);
    // Jinv[4] = -(0.00125*(4000.0*cos(theta_calf)*cos(theta_calf)*sin(theta_hip) - 4000.0*sin(theta_hip) + 4000.0*cos(theta_thigh)*cos(theta_thigh)*sin(theta_hip) - 1701.0*cos(theta_hip)*sin(theta_calf)*sin(theta_thigh) - 4000.0*cos(theta_calf)*cos(theta_thigh)*cos(theta_thigh)*sin(theta_hip) - 8000.0*cos(theta_calf)*cos(theta_calf)*cos(theta_thigh)*cos(theta_thigh)*sin(theta_hip) + 1701.0*cos(theta_hip)*cos(theta_calf)*cos(theta_thigh) + 4000.0*cos(theta_thigh)*sin(theta_hip)*sin(theta_calf)*sin(theta_thigh) + 8000.0*cos(theta_calf)*cos(theta_thigh)*sin(theta_hip)*sin(theta_calf)*sin(theta_thigh)))/(cos(theta_thigh)*sin(theta_calf) - 1.0*sin(theta_thigh) + cos(theta_calf)*cos(theta_calf)*sin(theta_thigh) + cos(theta_calf)*cos(theta_thigh)*sin(theta_calf));
    // Jinv[5] = (0.00125*(4000.0*cos(theta_hip)*cos(theta_calf)*cos(theta_calf) - 4000.0*cos(theta_hip) + 4000.0*cos(theta_hip)*cos(theta_thigh)*cos(theta_thigh) + 1701.0*sin(theta_hip)*sin(theta_calf)*sin(theta_thigh) - 4000.0*cos(theta_hip)*cos(theta_calf)*cos(theta_thigh)*cos(theta_thigh) - 8000.0*cos(theta_hip)*cos(theta_calf)*cos(theta_calf)*cos(theta_thigh)*cos(theta_thigh) - 1701.0*cos(theta_calf)*cos(theta_thigh)*sin(theta_hip) + 4000.0*cos(theta_hip)*cos(theta_thigh)*sin(theta_calf)*sin(theta_thigh) + 8000.0*cos(theta_hip)*cos(theta_calf)*cos(theta_thigh)*sin(theta_calf)*sin(theta_thigh)))/(cos(theta_thigh)*sin(theta_calf) - 1.0*sin(theta_thigh) + cos(theta_calf)*cos(theta_calf)*sin(theta_thigh) + cos(theta_calf)*cos(theta_thigh)*sin(theta_calf));
    // Jinv[6] = (5.0*(sin(theta_calf + theta_thigh) + sin(theta_thigh)))/sin(theta_calf);
    // Jinv[7] = (0.00125*(1701.0*cos(theta_hip) - 4000.0*cos(theta_thigh)*sin(theta_hip) + 4000.0*sin(theta_hip)*sin(theta_calf)*sin(theta_thigh) - 4000.0*cos(theta_calf)*cos(theta_thigh)*sin(theta_hip)))/sin(theta_calf);
    // Jinv[8] = (0.00125*(1701.0*sin(theta_hip) + 4000.0*cos(theta_hip)*cos(theta_thigh) - 4000.0*cos(theta_hip)*sin(theta_calf)*sin(theta_thigh) + 4000.0*cos(theta_hip)*cos(theta_calf)*cos(theta_thigh)))/sin(theta_calf);
    
    // // solver --- dq=inv(J)*dr
    // mju_mulMatVec(dq,Jinv,dr,3,3);
    // double theta_hip_ctrl = theta_hip + dq[0];
    // double theta_thigh_ctrl = theta_thigh + dq[1];
    // double theta_calf_ctrl = theta_calf + dq[2];
    // ********************************************************* jacobian approach solvers ********************************************************* //









    // ********************************************************* analytical solvers ********************************************************* //
    double theta_thigh_ctrl = 0;
    double theta_calf_ctrl = 0;

    if (d->time <=10)
    {
        // trajectory generation (x=0.183 y=-0.13205 z=[0.25 0.45] z_hip=0.599156) --- using cubic trajectory
        double t0 = 0;
        double tf = 10;
        double y0 = 0.2;
        double yf = 0.4;
        double a0 = (yf*t0*t0*(3*tf-t0) + y0*tf*tf*(tf-3*t0))/((tf-t0)*(tf-t0)*(tf-t0));
        double a1 = 6*t0*tf*(y0-yf)/((tf-t0)*(tf-t0)*(tf-t0));
        double a2 = 3*(t0+tf)*(yf-y0)/((tf-t0)*(tf-t0)*(tf-t0));
        double a3 = 2*(y0-yf)/((tf-t0)*(tf-t0)*(tf-t0));
        double x = 0;
        double y = a0 + a1*d->time + a2*d->time*d->time + a3*d->time*d->time*d->time;

        // analytical solver --- pick the appropriate theta1 theta2 from 4 sets of combinations in matlab "a1_analytic.m" --- case1_solution2 in this case
        double l1 = 0.2;
        double l2 = 0.2;
        double a =  x*x + l1*l1 + y*y - l2*l2;
        double b = 2*x*l1;
        double c = 2*y*l1;
        double theta1 = asin(((2*a*b - sqrt(4*a*a*b*b - 4*(b*b+c*c)*(a*a-c*c)))/(2*(b*b+c*c)))); 
        double theta2 = asin((x - l1*sin(theta1))/l2) - theta1;

        // input for pd controller
        theta_thigh_ctrl = -theta1;
        theta_calf_ctrl = -theta2;
    }
    else
    {
        theta_thigh_ctrl = 0;
        theta_calf_ctrl = 0;
    }
    // ********************************************************* analytical solvers ********************************************************* //

    // torque pd controller
    if (state == 4)
    {
        double target[]={0,theta_thigh_ctrl,theta_calf_ctrl,   //FR B
                         0,0.5,-1.7,                           //FL A
                         0,0.5,-1.7,                           //RR A
                         0,0.9,-2.2};                          //RL B
        
        for (i=0;i<nact;i++)
        {
            setpt[i]=target[i];
        }

        for (i=0; i<nact; i++)
        {
            tau[i] = -250*(q[i]-setpt[i])-10*u[i];
        }
    }      
}